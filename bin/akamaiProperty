#!/usr/bin/env node

// Copyright 2017 Akamai Technologies, Inc. All Rights Reserved
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

"use strict";

/**
 * Command line tool to interface with the WebSite library for manipulating the CDN activities on Akamai
 *
 * @author Colin Bendell <colinb@akamai.com>
 */

var path = require('path');
let untildify = require('untildify');
let WebSite = require('../index').WebSite;

let program = require('commander');

if ((process.versions["node"]).split('.')[0] < 7) {
    console.log("The Akamai CLI for Property Manager requires Node 7 or later.")
    process.exit()
}

process.on('unhandledRejection', (reason, p) => {
    console.log('Unhandled Rejection at: Promise', p, 'reason:', reason);
    // application specific logging, throwing an error, or other logic here
  });

function appName() {
    return process.argv[1].replace(/.*\//, "");
}
let app = "akamai property";

let section = "papi";
let config = untildify("~/.edgerc");
let debug = false;
let targetProperty;
let searchString;

process.env.NODE_TLS_REJECT_UNAUTHORIZED = "0";

function activateProperty(property, targetProperty, options) {
    
    let env = options.network.toUpperCase();
    return Promise.resolve()
        .then(() => {
            return property.lookupPropertyIdFromHost(targetProperty);
        })
        .then(data => {
            if (!options.propver) {
                options.propver = data.propertyVersion;
            }
            if ("BOTH" === env || env.startsWith("STAG"))
                return property.activate(   targetProperty, 
                                            options.propver, 
                                            WebSite.AKAMAI_ENV.STAGING,
                                            "Updated Automatically to staging.", 
                                            options.email);
            return Promise.resolve(data);
        })
        .then(data => {
            if ("BOTH" === env || env.startsWith("PROD"))
                return property.activate(   targetProperty, 
                                            options.propver, 
                                            WebSite.AKAMAI_ENV.PRODUCTION,
                                            "Updated Automatically to prod.", 
                                            options.email);
            return Promise.resolve(data);
        });
}

function deactivateProperty(property, targetProperty, options) {
    section = options.section || section;
    
    let env = options.network.toUpperCase();
    return Promise.resolve()
        .then(() => {
            if ("BOTH" === env || env.startsWith("STAG"))
               return property.deactivate(  targetProperty, 
                                            WebSite.AKAMAI_ENV.STAGING,
                                            "Automatically deactivating on staging.", 
                                            options.email);
            return Promise.resolve();
        })
        .then(() => {
            if ("BOTH" === env || env.startsWith("PROD"))
                return property.deactivate( targetProperty, 
                                            WebSite.AKAMAI_ENV.PRODUCTION,
                                            "Automatically deactivating on prod.", 
                                            options.email);
            return Promise.resolve();
        });
}


function updateProperty(property, targetProperty, options) {
    section = options.section || section;
 
    if (options.file)
        return property.updateFromFile( targetProperty, 
                                        options.file, 
                                        options.origin);
    
    if (options.srcprop)
        return property.copy(   options.srcprop, 
                                options.srcver, 
                                targetProperty);
    return Promise.resolve();
}

function deleteProperty(property, targetProperty, options) {
    return property.deleteProperty(targetProperty);
}

function createProperty(property, targetProperty, options) {
    let hostnames;
    if (options.hostnames) {
        hostnames = options.hostnames.split(',')
    }
    if (options.edgehostname) {
        process.env.USE_PROVIDED_HOSTNAME = 1;
    }
    if (!options.clone) {
        if (options.file) {
          return property.createFromFile(hostnames, 
                                        options.file,
                                        targetProperty,
                                        options.contract, 
                                        options.group,
                                        options.cpcode,
                                        options.origin,
                                        options.edgehostname,
                                        options.ruleformat);

        } else {
            return property.create(hostnames, 
                                        options.cpcode,
                                        targetProperty,
                                        options.contract, 
                                        options.group,
                                        null,
                                        options.origin,
                                        options.edgehostname,
                                        options.ruleformat)
        }
    } else {
        return property.createFromExisting(options.clone, 
                                        options.srcver, 
                                        options.nocopy,
                                        hostnames,
                                        targetProperty, 
                                        options.contract, 
                                        options.group,
                                        options.origin,
                                        options.edgehostname,
                                        options.cpcode,
                                        options.ruleformat
                                        )
    }
}

function retrieveProperty(property, targetProperty, options) {
    if (options.file) {
        return property.retrieveToFile( targetProperty, 
                                        options.file, 
                                        options.propver);
    } else if (options.format) {
        return property.retrievePropertyRuleFormat(targetProperty, options.propver)
    } else if (options.variables) {
        return property.getVariables(targetProperty, options.propver, options.file)
    } else {
        return property.retrieve(targetProperty, 
                                options.propver,
                                false)
        .then(data => {
            console.log(JSON.stringify(data,'',2));
            return Promise.resolve();
        })
    }
}

function retrieveNewestFormat(property) {
    return property.retrieveFormats(true)
    .then(data => {
        console.log(data);
    })
}

function retrieveGroups(property) {
    return property.retrieveGroups()
    .then(data => {
        console.log(data);
    })
}

function searchProperties(property, searchString, options) {
    return property.searchProperties(searchString)
    .then(data => {
        console.log(JSON.stringify(data,'',2))
    })
}

function retrieveFormats(property, options) {
    return property.retrieveFormats()
    .then(data => {
        console.log(JSON.stringify(data,'',2))
    })
}

function retrieveHostnames(property) {
    return property.retrieve(targetProperty, 0, true)
    .then(data => {
        console.log(JSON.stringify(data.hostnames.items, '', 2));
    })
}

function modifyProperty(property, targetProperty, options, command) {
    let version = options.propver ? options.propver : 0;
        if (options.addhosts) {
            return property.addHostnames(targetProperty, version, options.addhosts.split(','), options.edgehostname);
        } 
        if (options.delhosts) {
            return property.delHostnames(targetProperty, version, options.delhosts.split(','), options.edgehostname)
        }
        if (options.origin || options.forward) {
            return property.setOrigin(targetProperty, version, options.origin, options.forward);
        }
        if (options.edgehostname && command != "create") {
            return property.assignEdgeHostname(targetProperty, version, options.edgehostname, options.new);
        } 
        if (options.notes) {
            return property.setComments(targetProperty, version, options.notes);
        } 
        if (options.variables) {
                return property.setVariables(targetProperty, version, options.variables);
        }
        if (options.move) {
            return property.moveProperty(targetProperty, options.move)
        }
        if (options.ruleformat) {
            return property.setRuleFormat(targetProperty, version, options.ruleformat)
        } 
        if (options.sureroutemap || options.surerouteto || options.sureroutetohost) {
            return property.setSureRoute(targetProperty,
                                            version, 
                                            options.sureroutemap, 
                                            options.surerouteto,
                                            options.sureroutetohost);
        }
    }

function numberVersion(version) {
    if (version == null) {
        return 0;
    }
    
    let versionstring = version.toString();
    let returnstring;

    if (versionstring.match(/^stag/i)) {
            returnstring = -2;
    } else if (versionstring.match(/^prod/i)) {
            returnstring = -1;
    } else if (versionstring.match(/^late/i)) {
            returnstring = 0;
    } else if (!versionstring.match(/^\d*$/)){
            console.log("Unable to parse version string, using latest")
            return 0;
    } else {
        returnstring = version;
    }
    return returnstring;
}


function main()
{
    let options, command;
    process.argv[1] = "akamai property"
    var yargonaut = require('yargonaut')
    .style('blue.bold')
    var chalk = yargonaut.chalk()
    let yargs = require('yargs')
    
    options = yargs

    // Activate
    // Search
    .usage(chalk.bold("\nakamai property [subcommand] <options>"))
    .command("search", 'search for a property name', (yargs) => {
        yargs
            .option('string')
            .demandOption(['string'], "Enter a string to search for.")
    })
    .command("groups", 'retrieve account groups')
    .command('formats', 'get rules formats', {
        newest: { default: false }
    })
    .command("create [property]", "create a new property", {
        clone:  { "describe":"Source property to clone from", group:"Source"},
        srcver: { "describe":"Version for source property",group:"Source"},
        file:   { "describe":"Source file for new property rules", group:"Source"},
        hostnames: { "describe":"Comma delimited list of hostnames for property"},
        origin: { "describe":"Origin to set for property"},
        edgehostname: { "describe":"Edge hostname to use"},
        cpcode:   { "describe":"Use specified cpcode for new property",group:"Location"},
        contract:  { "describe":"Contract for new property",group:"Location"},
        group:  { "describe":"Group for new property",group:"Location"},
        nocopy: { "describe":"Do not copy cloned hostnames", group:"Source"},
        forward:   { "describe":"Forward host header (origin|incoming|<hostname>"},
        ruleformat:  { "describe":"Use specified rule format"},
        notes:   { "describe":"Version notes for the property version"},
        property:   { "demandOption": true, "description":false}
    })


    .command("activate [property]", 'activate the property', (yargs) => {
        yargs
            .positional('property', {
                hidden: true
            }).option('network', {
                describe: "Network for activation"
            })
            .option('propver', {
                describe: "Source version to activate"
            })
            .option('email', {
                describe: "Email for confirmation"
            })
            .demandOption(['property', 'network'], "Must provide a property and network PROD/STAGING/BOTH")
    })
    // Deactivate
    .command("deactivate [property]", 'deactivate the property', (yargs) => {
        yargs
            .positional('property', {
                hidden: true
            }).option('network', {
                describe: "Network for deactivation"
            })
            .option('email', {
                describe: "Email for confirmation"
            })
            .demandOption(['property', 'network'], "Must provide a property and network PROD/STAGING/BOTH")
    }, (argv) => {
        console.log("Doing stuff here")
    })
    .command("delete [property]", 'delete a property')
    .command('update [property]', 'update target property', {
        srcprop: { "describe":"Source property"},
        srcver: { "describe":"Source version"},
        file: { "describe":"File with JSON rules"},
        property: { "demandOption": true}
    })
    .command('retrieve [property]', 'retrieve rules from target property', {
        format: { "describe":"Rules format only"},
        hostnames: { "describe":"Retrieve hostnames for property"},
        variables: { "describe":"Retrieve user variables"},
        propver: { "describe":"Retrieve specified version"},
        property: { "demandOption": true}
    })
        .command('modify [property]', 'modify the target property', {
        addhosts:  { "describe":"Comma delimited list of hostnames to add", group:"Hostnames"},
        delhosts:  { "describe":"Comma delimited list of hostnames to delete", group:"Hostnames"},
        edgehostname: { "describe":"Edge hostname to use", group:"Hostnames"},
        origin: { "describe":"Origin to set for property", group:"Hostnames"},
        propver: { "describe":"Property version to operate on"},
        sureroutemap: { "describe":"Settings for SureRoute", group:"SureRoute"},
        surerouteto: { "describe":"Settings for SureRoute", group:"SureRoute"},
        sureroutetohost: { "describe":"Settings for SureRoute", group:"SureRoute"},
        forward:   { "describe":"Forward host header (origin|incoming|<hostname>"},
        ruleformat:  { "describe":"Use specified rule format"},
        notes:   { "describe":"Version notes for the property version"},
        move:   { "describe":"Group to move the property to"},
        variables: {"describe":"User variables file.  Format should be\n" +
                "\t\t\t\t   [{\n" + 
        '\t\t\t\t\t"name": "PMUSER_TEST",' + "\n" +
        '\t\t\t\t\t"value": "Foobar",' +"\n" +
        '\t\t\t\t\t"description": "This is my test variable",' +"\n" +
        '\t\t\t\t\t"hidden": false,' +"\n" +
        '\t\t\t\t\t"sensitive": false,' +"\n" +
        '\t\t\t\t\t"action":["delete","update","create"]' +"\n" +
      '\t\t\t\t   }]'},
        property:   { "demandOption": true, "description":false}
    })
    .option("s", {
        alias: "section",
        description: "Configuration section"
    })
    .option("c", {
        alias: "config",
        description: "Configuration file"
    })
    .option("d", {
        alias: "debug",
        description: "Turn on debugging"
    })
    .showHelpOnFail(true)
    .version(false)
    .demandCommand()
    .epilog("Visit our github repository at https://github.com/akamai/cli-property")
    .help('help')
    
    .argv;

    console.time(app);
    var begin=Date.now();

    let property;

    if (options) {
        targetProperty = options.property || null;
        section = options.section || section;
        config = options.config || config;
        debug = options.debug || debug;
        property = new WebSite({path:config, section: section, debug: debug});
    
        if (options.propver) {
            options.propver = numberVersion(options.propver)
        }
        if (options.srcver) {
            options.srcver = numberVersion(options.srcver)
        }
    } else {
        property = new WebSite({path:config, section: section});
    }
    
    Promise.resolve()
            .then(() => {
                switch(options._[0]) {
                    case "search":
                        return searchProperties(property, options.string, options)
                        .then(() => {
                            var end=Date.now();
                            var timeSpent=(end-begin)/1000/60+" mins";
                        })
                    case "activate":
                        return activateProperty(property, targetProperty, options)
                        .then(() => {
                            console.log("Activation Complete")
                            var end=Date.now();
                            var timeSpent=(end-begin)/1000/60+" mins";
                            console.log("Activation: " + timeSpent)
                        })
                        break;
                    case "create":
                        return createProperty(property, targetProperty, options)
                        .then(() => {
                            if (options.forward || options.variables || options.notes) {
                                return modifyProperty(property, targetProperty, options, command)
                            } else {
                                return Promise.resolve();
                            }
                        })
                        .then(() => {
                            console.log("Creation complete")
                            var end=Date.now();
                            var timeSpent=(end-begin)/1000/60+" mins";
                            console.log("Creation: " + timeSpent)
                            return Promise.resolve();
                        })
                        break;
                    case "deactivate":
                        return deactivateProperty(property, targetProperty, options)
                        .then(() => {
                            console.log("Deactivation Complete")
                            var end=Date.now();
                            var timeSpent=(end-begin)/1000/60+" mins";
                            console.log("Deactivation: " + timeSpent)

                        })
                        break;
                    case "delete":
                        options.network = "BOTH"
                        return deactivateProperty(property, targetProperty, options)
                        .then(() => {
                            return deleteProperty(property, targetProperty, options)
                        })
                        .then(() => {
                            console.log("Delete Complete")
                            var end=Date.now();
                            var timeSpent=(end-begin)/1000/60 +" mins";
                            console.log("Delete: " + timeSpent)

                        })

                        break;
                    case "modify":
                        return modifyProperty(property, targetProperty, options)
                        .then(() => {
                            var end=Date.now();
                            var timeSpent=(end-begin)/1000/60 +" mins";
                            console.log("Modify: " + timeSpent)
                        })                                                    

                        break;
                    case "retrieve":
                        if (options.hostnames) {
                            return retrieveHostnames(property, targetProperty)
                        } else {
                            return retrieveProperty(property, targetProperty, options)
                        }
                        break;
                    case "update":
                        return updateProperty(property, targetProperty, options)
                        .then(() => {
                            console.log("Update Complete")
                            var end=Date.now();
                            var timeSpent=(end-begin)/1000/60 +" mins";
                            console.log("Update: " + timeSpent)
                        })

                        break;
                    case "groups":
                        return retrieveGroups(property)
                        break;                    
                    case "formats":
                        if (options.newest) {
                            return retrieveNewestFormat(property)
                        } else {
                            return retrieveFormats(property)
                        }
                        break;
                }
            })
            .catch((error) => {
                console.error("ERROR: ", error.body || JSON.stringify(error));
                if (error.stack) {
			console.log(error.stack);
			process.exit(1)
		}
            });
    }

main();
